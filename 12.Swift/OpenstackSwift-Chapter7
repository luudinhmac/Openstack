chapter7: Tính năng API nâng cao
Trong khi việc CRUD là các thao tác nền tảng của bất kỳ hệ thống lưu trữ nào (đề cập ở chapter6) Swift cung cấp 1 API phong phú với nhiều tính năng hữu ích nâng cao hơn. CÙng với lớp giữa của nó, swift làm giảm thiếu số lượng phát triển tùy chọn cần thiết để làm cấu hình hệ thống mạnh mẽ và linh hoạt hơn. Chương này cung cấp tóm tắt và các trường hợp và giới thiệu cho bạn tài liệu hướng dẫn chi tiết hơn cho các tính năng thú vị nhất của Swift, nếu 1 trong số các tính năng giải quyết đc vấn đề cho ban, hãy sử dụng nó, còn nếu không hãy vô hiệu hóa nó, Mặc dù nó là 1 phần cài đặt mặc định, không ai trong số này là cần thiết cho sử dụng mặc định Swift, nhưng sẽ hữu ích khi bạn cần chúng.
Để thực hiện chức năng này là đơn giản, dễ sử dụng nhất, chúng ta sẽ được cung cấp mã mẫu sử dụng yêu cầu đơn giản dòng lệnh HTTP (với cURL) vào cuối chương. Bạn cũng có thể sử dụng tiện ích dòng lệnh (được cài đặt qua gói swiftclient python), mà tường là kết quả trong các lệnh đợn giản, hoặc sử dụng 1 thư viện API theo ngôn ngữ bạn lựa chọn. Chúng tôi sử dụng cURL trong các mẫu mã của chúng t để có thể thấy các verb HTTP và cá header, làm cho nó dễ dàng hơn với giao diện khác.


Đối tượng lưu trữ lớn
Swift giới hạn kích thước tối đa cho 1 đối tượng là 5gb, để đảm bảo các đối tượng được trải ra đồng đều trên các đĩa. Nếu bạn có kế hoạch lưu trữ đối tượng lớn hơn kích thước tối đa, bạn có thể sử dụng các SLO(static large object) hoặc DLO(dynamic large object) middleware. Bởi ở mức thấp nhất, Swift không lưu trữ đối tượng lớn hơn kích thước tối đa, cả tĩnh và động đều được được chia thành các phân đoạn trung gian sau này có thể lấy lại. 
- Các đối tượng lớn tĩnh đựa trên 1 biểu hiện người dùng định nghĩa liệt kê 1 cách rõ ràng phân khúc tạo nên đối tượng. Điều này cho phép Swift hoàn toàn mềm dẻo, linh hoạt trong việc lưu trữ phân khúc trong các địa điểm phân phối và thu hồi chúng 1 cách song song khi được tập hợp lại. Sử dụng SLOs có lợi thế bổ sung là tự tài liệu liên quand dến các phân đônạ tạo nên 1 đối tượng lớn được đưa ra. Chúng ta được khuyến cáo nên sử dụng SLOs hơn DLOs trừ khi có nhu cầu cụ thể cho DLOs. Thông tin chi tiết về API của SLOs có thể được tmf thấy ở trang:http://docs.openstack.org/developer/swift/middleware.html#module-swift.common.middleware.slo
- Các đối tượng lớn động cho phép các bộ phân khúc được định nghĩa bởi tên 1 container và 1 tiền tố đối tượng, do đó việc xác định dựa tên của 1 đoạn  phân khúc động thay vì dựa bảo 1 dấu hiệu, biêu hiện. Ví dụ bạn có thể tải lên các tập tin bigfile-part1 bigfile-part2 bigfile-part3... vào 1 container có tên là large_file_segments và tạo ra 1 biểu hiện cho thấy rằng các tập tin có tiền tố large_file_segments / bigfile-part đều nên hiểu là phân khúc của 1 đối tượng lớn là bigfile (không có bigfile-part hay j tương tự thế) trong 1 container được gọi là large-file (đối tượng có thể nằm ở 1 container hay nh container khác nhau là do bạn chọn). Ngược lại với các biểu hiện SLO, nơi chứa các danh sách đầu đủ của các phân đoạn. Biểu hiện DLO chỉ cần xác định các container và tiền tố các đối tượng đc cho là phân khúc. Các biểu hiện được tải lên URL từ đõ dẫn đến DLO được lấy ra
Nếu như 1 phân khúc mới bigfile-part4 được tải lên sau đó, tương lai bigfile sẽ bao gồm phân khúc mới này. Tuy nhiên nên nhở rắng tính nhất quán sẽ được đảm bảo cuối cùng vì vậy có thể khi tải lên 1 phân khúc mới, hệ thống tuy được báo thành công nhưng khi lấy ra đối tượng sẽ không bao gồm phân khúc mới này do chưa được đảm bảo tính nhất quán,
Bởi DLOs là đông, nên ko có cách nào để nhận ra được 1 phân khúc mới đã được phổ biến trên các cluster chưa (ngược lại SLOs có dấu hiệu để liệt kê phân đoạn 1 cách rõ ràng, vì vậy nếu 1 đoạn ko tồn tại họ có thể chỉ ra lỗi)
nếu muốn biết chi tiết apu cho DLOs tham khảo: http://docs.openstack.org/developer/swift/overview_large_objects.html#dynamic-large-objects
Mặc dù chúng ta được đề nghị lưu SLOs hơn DlOs để tránh các vấn đề về tính  nhất quán (tức là có khả năng ko lấy lên 1 phân khúc mới tải lên), DLOs vó thể là giải pháp tốt nhất cho 1 số ứng dụng. 1 ứng dụng có thể được tải lên log file thành các phân đoạn trong từng giờ, trong khi vẫn có thể lấy lại dạng ghép của các phân đoạn. Mặt khác có thể lưu trữ 1 dòng video trực tiếp trong khi chi phép thời gian thực cho từng dòng. Nói chung, các ứng dụng hưởng lợi từ việc truyền dữ liệu có xu hướng ứng dụng tốt DLOs. Tùy nhiên ngoài việc tránh vấn đề nhất quán, SLOs cho phép phân đoạn đưaọc đặt trong 1 container bất kỳ trong aacoung, và cho phép các phân đoạn có tên tùy ý.
Khi sử dụng dữ liệu lớn, cần tải lên các phân đoạn trước r mới tạo dấu hiệu để tránh lỗi truy cập phân đoạn ko tồn tại.

Object versioning
Nếu như bạn muốn bảo vệ đối tượng khỏi việc chống ghi đè vô tình hoặc nếu bạn muốn tự động giữ lại các phiên bản cũ của đối tượng thì object versioning Swift là câu trả lời. Để kích hoạt versioning trong target container của bạn, trước tiên tạo 1 container phụ riêng biệt để giữ các phiên bản cũ của các target container, sau đó kịch hoạt object versioning trong container target bằng cách thiết lập metadata header X-Version-Location với tên của container phụ chứa phiên bản cũ.
Ví dụ, bạn có thể tạo ra 1 container có tên fragile_data và 1 container có tên là old_versions, và sao đó thiết lập header X-Versions-Location của  fragile_data có giá trị là old_versions. Sau đó, fragile_data sẽ là nơi chứa tất cả các phiên bản cập nhật cuối của đối tượng, và các phiên bản trước đó sẽ được tìm thấy trong old_version container. Nếu như đối tượng ở trong fragile_data bị xóa. phiên bản tiếp theo gần nhất sẽ được chuyển từ container old_version tới container fragile_data (container old_version vẫn có thể truy cập trực tiếp nếu muốn)
Object versioning đòi hỏi phải cấu hình container server bằng các thêm vào dòng low_version = True trong file config

Đối tượng hết hạn (Object Expiration)
Object Expiration cho phép chỉ định các đối tượng tự động bị xóa ở 1 thời điểm. Ví dụ để tiết kiệm không gian ổ đĩa bằng các xóa các dữ liệu tạm thời hoặc tuân thủ theo các chính sách đề ra. Sử dùng tính năng này bằng cách thiết lập header metadata của đối tượng ở trường X-Delete-At đánh dấu 1 thời gian cụ thể. Cuối cùng, object auditor và object repilcator sẽ xem xét đối tượng và nếu thời điểm hiện tại trùng với trường X-Delete-At nó sẽ xóa đối tượng.
X-Delete-At nên được thiết lập để 1 giá trị thời gian đại diện bởi số nguyên giây. Để thuận tiện, bạn có cách khác có thể sử dụng tiêu đề X-Delete-After, nó sẽ được ánh xạ tới giá trị X-Delete-At. Nếu thời điển hiện tại là 1,400,000,000 giây kể từ thời điểm Epoch (01/01/1970 nửa điêm theo giờ UTC) bạn đặt X-Delete-After là 86400 cho đối tượng, và đối tượng sau đó sẽ hết hạn và bị xóa từ thời điểm 1400086400.

Temporary URL Middleware (url tạm thời)
Một số ứng dụng tạo ra dữ liệu cần phải được công khai tạm thời. Ví dụ ứng dụng chia sẻ file có thể cho phép bạn tải lên các tập tin và trong 1 thời gian ngắn cấp quyền truy cập cho người dùng khác thông qua URL hạn chế, thường gọi là URL tạm thời, Vì URL hết hạn sau 1 thời gian cố định, hệ thống không cần phải theo dõi và sẽ loại bó nó ra khỏi truy cập.
Bởi các url tạm thời chứa thời gian hết hạn của mình để tránh dùng trộm, nên đó là 1 hành vi xuất sắc từ quan điểm bảo mật. Không có hành động nào cần thiết xảy ra để thu hồi quyền truy cập. Không có tiến trình nào cần xảy ra nên sẽ ko có tiến trình bị lỗi tránh gây ra lỗ hổng bảo mật. Nếu thời gian thực hiện là nhiều hơn so vs url tạm thời, thì các Url này sẽ bị hết hạn và ko đc sử dụng lại.
Url tạm thời có nhiều ứng dụng, một ví dụ khác là nếu 1 tổ chức muốn chấp nhận thanh toán từ khách hàng cung cấp 1 liên kết đến nội dung độc quyền nhưng khuyến khích khách hàng gửi các email link tới những người không trả tiền.
Các Url tạm thời trung gian cho phép không chỉ GET tạm thời, mà còn cho phép thực hiện bất kỳ hành động nào từ HTTP mà tác giả cần. Ví dụ bạn có thể tạo ra 1 container  trong đó có chứa các tập tin có thể được tải lên nếu người dùng có 1 url tạm thời về PUT hợp lệ.
Url tạm thời dựa trên chữ ký mật mã của đối tượng Url, phương thức HTTP và 1 dấu thời gian. Khi tạo ra 1 Url tạm thời, những gá trị này được nối với nhau vàký kết với Url tạm thời chính, được lưu trữ như metadata ở tài khoảnn đặc quyền (tài khoản đặc quyền là tài khoản có thể đọc, ghi chỉ định bởi người có quyền truy cập admin vào tài khoản, thường là chu sở hữu tài khoản).
Nếu chữ ký, dấu hiệu được xác nhận, và dấu thời gian chưa hết hạn, khách hàng có thể truy cập vào các URL với phương pháp nhất định

Form post middleware
Một trường hợp sử dụng Swift thường là cho phép người dùng sử dụng 1 hinhg thức HTML để upload file.Form Post middleware giúp bạn tránh 1 số rắc rối của việc viết code phía máy chủ, xác nhận việc ủy quyền, phân thích các response HTML, và ánh xạ tới các lời gọi API Swift. Với middleware này, bản thân Swift có thể chấp nhận các mẫu file upload để lưu trữ. Form Post middleware cho phép bạn:
- Upload nhiều file được chỉ định trên cùng 1 hình thức, thềm vào trước 1 tiền tố tĩnh cho tên mỗi tập tin nhất định
- Chuyển thới URL khác (ví dụ như cảm ơn...) sau khi tải lên hoàn tất.
- Thiết lập tối đa kích thước tập tin cho phép, để ngăn chặn lạm dụng hệ thống cũng  như các cuộc tấn công mã độc hoặc sự bất cẩn người dùng
Bởi Form post middleware thường được sử dụng để cho phép upload trên web để người dùng ko xác nhận tong Swift nên nó thường sử dụng kết hợp với 1 URL tạm thời mà bạn đã tạo ra để cho phép POST hoạt động.


Thay đổi metadata
Chúng ta đã thấy được 1 số các trường trong metadata trong hệ thống Swift. Ví dụ từ chương này bao gồm các khóa bí mật Url tạm thời, các dấu hiệu của đối tượng lưu trữ dữ liệu dung lượng lớn, các trường thời gian của đối tượng, container và object versioning
Lưu ý rằng các metadata có thể được liên kết vs 1 account (ví dụ, các khóa bí mật url tạm thời) với 1 container (ví dụ: các đối tượng tương ứng versioning của các đối tượng trong container này) hoặc với 1 đối tượng (ví dụ: trường hết hạn).
Metadata là rất hữu ích với nhiều mục đích khác nhau, Swift khiến nó dễ dàng để có thể thêm vào metadata, đơn giản chỉ cần gửi yêu cầu POST hoặc PUT header. Bạn có thể thêm vào metadata của 1 tài khoản, 1 container, haowcj 1 object. Tiêu đề metadata tùy chinht của bạn phải bắt đầu với XAccount_meta cho metadata của container, X-Containe-Meta cho metadata của container và X-Object-Meta đối với metadata của object. Swift sẽ lưu trữ metadata bao foomg các cả header, khi 1 hành đông HEAD hay GET được thực hiện trên object, conaitner hoặc account.
Sử dụng metadata Swift để tránh những vấn đề của ứng dụng khi duy trù 1 cơ sở dữ liệu riêng biệt về tài nguyên Swift. Metadata được lưu trữ với tất cả sự đảm bảo độ bện dữ liệu và không yêu cầu độ trễ để lấy. Ví dụ 1 nhà sản xuất video có thể lưu trữ các định dạng video và thời gian cùng với nội dung; 1 tài liệu sẽ chứa thông tin tác giả; và 1 trình tự chứa quá trình mà nó tạo ra. Trong tất cả những trường hợp này, các siêu dữ liệu có thể được lấy ra vs 1 yêu cầu nhanh HEAD chứ ko phải GET để download dữ liệu (có thể rất lớn).

Puting và Posting metadata
Cả account và container hỗ trợ 2 cách khác nhau để thay đổi metadata. Nếu bạn PUT tới account hoặc container và bao gồm metadata trong yêu cầu của bạn, bạn loại bỏ bất cữ điều j mà metadata cũ đã có trước đó và thay thế hoàn toàn bằng metatada mới mà bạn vừa cung cấp. Tuy nhiên nếu bạn POST tới account hoặc container và bao gồm metadata trong yêu cầu, nó sẽ chỉ thay đổi các trường mà bạn có. Nói cách khác, chúng ta nói rằng các metadta trước đó có những điều sau:
X-Container-Meta-A: 1
X-Container-Meta-B: 2
X-Container-Meta-C: 3
Nếu bạn PUT tới container với X-Container-Meta-B: 100 bạn sẽ update giá trị B nhưng cũng đồng thời xóa giá trị A và C. Tuy nhiên nếu bạn POST thì giá trị B sẽ thay đổi còn A và C giữ nguyên
PUT và POST cấp cho người dùng tùy chọn thay thế hoặc cập nhật metadata của account và container. Tuy nhiện, vì những lý do lịch sử, các quy tắc metadata đối tượng là khác nhau. Trong trường hợp với metadata cảu đối tượng, POST vs PUT là như nhau. Hay nói rằng metadata của đối tượng trước đó đã xử lý những điều sau:
X-Object-Meta-A: 1
X-Object-Meta-B: 2
X-Object-Meta-C: 3
Nếu bạn sử dụng lệnh PUT hay POST với metadata của đối tượng, thì sẽ có tác dụng như nhau là đều bị ghi đè lên metadata cũ mà ko cập nhật như đối với account hay container. Không có cách nào để cập nhật metadata của đối tượng và để lại các giả trị khác, dùng HEAD để dọc và POST để sửa.
PUT vs POST: sự khác nhau giữa cập nhật và ghi đè với account và container. và đều ghi đè với object.

Cross-Origin Resource Sharing
Swift hỗ trợ chia sẻ tài nguyên giữa các gốc (CORS) cho phép các nhà phát triển ứng dụng upload dữ liệu lên Swift hoặc lưu trữ nội dung web trực tiếp từ Swift mà nó không cần xây dựng và duy trì 1 lớp proxy riêng để có mô hình bảo mật xung quanh nguồn gốc Web. Trên ứng dụng web chính sách same-origin đã trở thành 1 tiêu chuẩn trình duyệt để ngăn chặn 1 số vấn đề về an ninh. Ví dụ: khá nguy hiểm nếu cho phép 1 kịch bản từ http://host1.foo.com truy cập tới tài liệu đối tượng (Document Object Model (DOM)) của 1 trang http://host2.foo.com và các trình duyệt cấm việc làm như vậy. Tuy nhiên nếu 2 trang phối hợp với nhay, mỗi người có thể rõ ràng cho phép người khác truy cập vào nó và nó được coi là an toàn để 1 trang caaos quyền truy cập đến 1 máy chủ khác.
Nếu bạn đang sử dụng Swift cluster để lưu trữ tài nguyên (như JAVA script) sẽ hiện trị trên trang web, bạn có thể muốn sử dụng CORS nói với các tình duyệt cung cấp miễn chính sách  same-origin trong trường hợp đặc biệt này. Ví dụ bạn có thể muốn cho phép 1 ứng dụng web lưu trữ tại địa chỉ http://app.example.com để tại lên hình ảnh trực tiếp tới http://images.example.com mà được hỗ trợ bởi 1 Swift cluster.
Swift cho phép người dùng thiết lập tiêu đề CORS trên dữ liệu được lưu trữ trong Swift. Tiêu đề CORS được thực thi trên mỗi container. Để sử dụng header CORS với dữ liệu trên Swift cluster, thiết lập metadata thích hợp trên container của bạn. Thiết lập metadata của container làm cho tất cả các request của object trong container trả về với header CORS và phản hồi thích hợp với các OPTION của yêu cầu. Header bạn có thể đặt trên container là:
X-Container-Meta-Access-Control-Allow-Origin
X-Container-Meta-Access-Control-Max-Age
X-Container-Meta-Access-Control-Allow-Headers
X-Container-Meta-Access-Control-Expose-Headers
Đây là các header metadata tiêu chuẩn, nhưng khi 1 yêu cầu CORS được thực hiện đối với container hoặc object trong container, những metadata làm cho Swift thiết lập các CORS phản hồi

Swift Cluster Info
Chúng ta đã nhắc tới  Swift’s cluster info ở chapter 5. Bây giờ chúng ta sẽ thảo luận làm sao để các dev có thể tận dụng lợi thế của tính năng này.
Vì Swift đang được phát triển, với các chức năng mới mạnh mẽ hơn thêm vào mỗi bản phát hành, các dev có thể muốn kiểm tra khẳ năng của 1 cụm Swift được xác định xem nó có tính năng j đặc biệt hay ko, ngoài việc kiểm tra sự hiện diện hay vắng mặt, Swift cluster cung cấp tra cứu giá trị quan trọng với 1 số thông số. Các dev có thể sử dụng các giá trị tham số để hướng dẫn các quyết định và cách sử dụng các cluster.
Thông tin cluster hiện tại bao gồm sự hiện diện hay vắng mặt của 1 số tính năng quan trọng (như ACL account) và nhiều giá trị cấu hình (chẳng hạn như kích thước tập tin tối đa và độ dài tên tối đa). Bởi vì thông tin cluster là tính năng tương đối mới, nó thường xuyên được cập nhật với thông tin bổ sung, Xem cuối chương này cho 1 ví dụ về cách bạn có thể sử dụng chức năng thông ti cluster. Thử nó và bạn có thể tìm thấy thông tin hữu ích.
Thông tin Swift cluster là rất quan trọng cho các ứng dụng có ỹ nghĩa chạy với nhiều Swift cluster với nhiều cấu hình, hoặc chống lại việc 1 cụm Swift với các tùy chọn cấu hình có thể thay đổi.
Ví dụ: ứng dụng cảu bạn có thể tự động tạo SLOs bằng cách phân chia file dữ liệu lớn được upload bằng user. Ứng dụng của bạn sẽ cần phải biết kích thước tối đa cho phép hoặc kích thước của 1 phân khúc. Nếu bạn đã cho phé tải tập tin, ứng dụng của bạn có thể xác định xem liệu cụm Swift đã kích hoạt Form Post middleware (và sử dụng nó nếu có)

Phạm vi yêu cầu (range request)
Mặc dù Swift là tueeytj vời để lưu trữ khối lượng dữ liệu lớn (bao gồm các file), đôi khi, các vấn đề mạng, lỗi phần mềm, lỗi con người gây ra tải thất bại khi nó gần như đã hoàn thành. Nếu ứng dụng cảu bạn đã thành luồng dữ liệu vào ổ, nó có thể chỉ cần 1 phần nhỏ của object trong Swift.
Vì lý do này, Swift hỗ trợ phạm vi yêu cầu để lấy chỉ phần đối tượng mà khách hàng mong muốn, giảm độ trễ và tải lên cluster. Phạm vi yêu cầu cũng có thể được sử dụng để truyền khối kích thước hợp lý cho người sử dụng, trong trường hợp toàn bộ đối tượng có thể là không mong muốn. Ví dụ: nhiều trang web xem phim cho ta thấy rằng người dùng thường tình cở duyệt chỉ vài giây đầu tiên của 1 đoạn video
Khi node proxy giao tiếp với node object, sự gián đoạn có thể xảy ra 1 phần thông qua việc đọc đối tượng. Trng trường hợp này tiến trình proxy server sẽ liên lạc với các bản sao khác đối tượng, phát hành yêu cầu phạm vi bắt đầu sau byte cuối cùng mà nó nhận được thành công từ node object đầu tiên. Điều này xảy ra phía sau nên client ko thể nhận thấy, nó chỉ là 1 trong nh tính năng dự phòng mà Swift cung cấp.

Domain Remap Middleware
Domain Remap Middleware cung cấp 1 cách dễ dàng cách để tham khảo 1 accoung hoặc 1 container bằng DNS hostname thày vì cả 1 đường dẫn, Swift thường đề cập đến 1 đối tượng bằng 1 URL như http://swift.example.com/v1/account/container/object. Nếu thay vào đó bạn muốn tham khảo http://swift.example.com/v1/account/container/object hoặc  http://container.account.swift.example.com/object. thì Domain Remap Middleware sẽ giúp bạn.
Tính năng này rất hữu ích trong 1 số loại ứng dụng phân phối nội dung. Nếu cụm cluster tổ chức theo các loại khác nhau hoặc các tầng khác nhau, nó có thể thuận tiên vứi nội dung của bạn xuất hiện cho người dùng có nguồn gốc từ các miền khác nhau. Ví dụ, Swift cluster của bạn có thể giữ các bức ảnh và video từ các sự kiên thể thao, và bạn muốn làm cho nó sẵn sàng với nguwofi sử dụng tại các địa chỉ http://football.video.swift.example.com/filename.jpg. Nếu bạn sử dụng Domain Remap Middleware và nếu bạn có account được gọi là video và 1 container gọi là football bạn có thể thực hiện điều này mà ko cần bất kỳ mã tùy cỉnh nào. Tạo 1 bản ghi CNAME trong cấu hình DNS từ football.example.com đến football.video.swift.example.com để tạo thành 1 đường dẫn đơn giản hơn.
1 gói middleware, cname_lookup có thể được sử dụng kế hợp với Domain Remap để cung cấp tên miền thân thiện ánh xạ trực tiếp tới account hoặc container cụ thể.  Tính năng này cho phép ahs xạ tên máy ngắn gọn hơn. Với việc kích hoạt cname_lookup, Swift sẽ sử dụng DNS để giải quyết canonial name cho bất kỳ tên nào. Nó cho phép admin cấu hình các domain tùy ý như football.example.com cho account hoặc container.
Lưu ý rằng nếu tên acount là AUTH_acct, tên domain trở thành acct.swift.example.com vì gạch dưới ko cho phép ở trong tên miền, Điều này cũng áp dụng tương tự với container, thiết lập này đòi hỏi DNS có ký tự dại diện.

Static Web Hosting
Static web trung gian cho phép bạn phục vụ nội dung HTML trực tiếp từ các container trong cụm Swift của bạn, bỏ qua sự cần thiết ứng dụng tùy chỉnh. StaticWeb thực hiện điều này bằng cách phép bạn thiết lập metadata trên 1 container quy định cụ thể  tên object hiển thị đáp ứng với 1 GET trên container. Index.html là 1 giá trị truyền thống nhưng bạn có thể sử dụng bất kỳ tên nào bạn muốn.
Nếu bạn muốn các nội dung được công khai, bạn sẽ cần 1 số cơ chế để cấp quyền truy cập. Một giải pháp thông thường là container ACLs, nơi có thể được sử dụng hoặc để làm 1 container hoằn toàn công khai, có theer đọc được từ 1 HTTP nhất định, Ngoài ra, nếu bạn sử dụng SwiftStack Auth như hệ thống xác thực cảu bạn, nó có thẻ thiết lập 1 cookie khi xác nhận thành công. Coockie này chưa token auth và middleware SwiftStack Auth xác minh token auth của cookie cấp quyền truy cấp.
StaticWeb middleware xử lý các yêu cầy GET container (tức là các trang index.html), thiết lập Content-Type là text/html và cho phpes 1 số tính năng hữu ích khác:
- Container listing, có thể theo kiểu file CSS.
- "Pseudo-directories" mà có thể được liệt kê chỉ ra danh sách container chứa.
- Trang lỗi tùy chỉnh, cs thể được quy định với trang mặc định lỗi.
Tùy theo yêu cầu của bạn, StaticWeb middleware có thể là 1 cách dễ dàng để thực hiện tính sẵn sàng cao Web-hossting, vì các vấn đề dự phòng, thông lượng và sức chứa có thể được giải quyết trực tiếp bởi Swift. Toàn bộ trang wrb có thể dễ dàng rôt chức chỉ đơn giản bằng cách đặt các file trong cluster Swift, nếu bạn đặt các dịch vụ DNS geo-aware phía trước các node của Swift multi-region, bạn có thể thực hiện 1 loại đơn giản mạng phân phối nội dung (CDN), giảm thiểu độ trễ khách hàng web gần đó.
Có thể sử dụng tính năng này để kéo thả đối tượng.

Content-Type Header
Các header Content-Type có thể được sử dụng phục vụ cho nội dung trang web trực tiếp từ Swift. Nếu 1 khách hàng đặt Content_type vào 1 yêu cầu PUT, cùng Content-Type sẽ được trả về 1 GET. Trình duyệt nhận ra nhiều tiêu đề Content-Type và hiển thị hình ảnh hoặc có thể trình bày nội dung nguyên bản (cí dụ âm thanh, hình ảnh) hoặc gọi các ứng dụng thích hợp để hiển thị dữ liệu
Tính năng này là rất dễ sử dụng mà nó còn ko đòi hỏi phải giải thích thêm nhiều, Nhưng nó có giá trị nổi bật, và lợi ích to lớn với việc phục vụ nội dung trực tiếp từ Swift. Bao gồm không chỉ dự phòng, thông lượng, mà còn là tiềm năng cho các điểm địa lý, nhận thức về sự hiện diện nhiều cụm nhiều khu vực. Đối với lý do này, chúng tôi muốn mang tính nawnng này đến cho các dev, họ có thể đơn giản hóa kiến trúc.

Bulk Operations Middleware
Hàng loạt các hoạt động trung gian cho phép bạn tải lên hay xóa nhiều đối tượng với 1 yêu cầu HTTP. Tải lên hàng loạt bao gồm tải lên 1 tập tin dữ liệu sẽ được nén ở phóa máy chủ, xóa hàng loạt được thực hiện thông qua yêu cầu POST liệt kê các container và các đối tượng bị xóa; Swift proxy sau đó ban hành nhiều yêu cầu DELETE. Trong cả 2 trường hợp, dev tránh những Nhiều yêu cầu HTTP và thời gian quay vòng, và cố gắng tập hợp nhiều phản hồi thành 1 giá trị trả về hữu ích.
Tải lên hàng loạt là 1 cách hiệu quả để nhập vào 1 lượng khá lớn dữ liệu. Mặc dù không hữu dụng với BigData up load petabyte, nhwung tải lên hàng loạt cót thể dễ dàng quản lý hàng ngàn tập tin và nhiều gigabyte dữ liệu.
Xóa hàng loạt là cách ưa thích để tẩy 1 lượng lớn các tập tin: ví dụ khi xóa 1 container với hàng ngàn object. Xóa hàng loạt cũng có thể dùng để xóa nội dung của 1 account nhưng trong trường hợp đó có 1 sự thay thế đáng giá: nếu 1 admin Swift cluster thực hiện 1 DELETE trên 1 acoount của mình, sau đó, 1 process background sẽ xóa tất cả nội dung của 1 account.

VÍ DỤ CODE: